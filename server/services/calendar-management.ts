import { storage } from "../storage";
import { generateMeetingSummaryFromNotes, generateMeetingAgenda } from "../ai-service";
import { sendMeetingReminderNotification } from "./slack-service";

/**
 * Get upcoming meetings for a user
 */
export async function getUpcomingMeetings(userId: number) {
  try {
    const events = await storage.getEventsByUserId(userId);
    const now = new Date();
    
    // Filter for upcoming meetings (events that haven't ended yet)
    return events.filter(event => {
      const endTime = new Date(event.endTime);
      return endTime > now;
    });
  } catch (error) {
    console.error(`Error getting upcoming meetings for user ${userId}:`, error);
    return [];
  }
}

/**
 * Send meeting reminder
 */
export async function sendMeetingReminder(userId: number, eventId: number) {
  try {
    const event = await storage.getEvent(eventId);
    
    if (!event || event.userId !== userId) {
      console.error(`Event ${eventId} not found or does not belong to user ${userId}`);
      return false;
    }
    
    const user = await storage.getUser(userId);
    if (!user) {
      console.error(`User ${userId} not found`);
      return false;
    }
    
    // Generate meeting agenda if not already present
    let agenda = event.description || '';
    
    if (!agenda.includes('Agenda:')) {
      const generatedAgenda = await generateMeetingAgenda(
        event.title,
        new Date(event.startTime).toISOString(),
        event.attendees || []
      );
      
      if (generatedAgenda) {
        agenda = generatedAgenda;
        
        // Update the event with the generated agenda
        await storage.updateEvent(userId, eventId, {
          description: agenda
        });
      }
    }
    
    // Format the email
    const startTime = new Date(event.startTime);
    const endTime = new Date(event.endTime);
    const timeString = `${startTime.toLocaleTimeString()} - ${endTime.toLocaleTimeString()}`;
    
    const meetingReminder = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
        <h1 style="color: #2563EB;">Meeting Reminder</h1>
        <p>Hello ${user.fullName || user.username},</p>
        <p>This is a reminder for your upcoming meeting:</p>
        
        <div style="background-color: #f8fafc; border-left: 4px solid #2563EB; padding: 15px; margin: 20px 0;">
          <h2 style="margin-top: 0; color: #2563EB;">${event.title}</h2>
          <p><strong>Time:</strong> ${timeString}</p>
          <p><strong>Date:</strong> ${startTime.toLocaleDateString()}</p>
          ${event.location ? `<p><strong>Location:</strong> ${event.location}</p>` : ''}
          ${event.meetingUrl ? `<p><strong>Meeting URL:</strong> <a href="${event.meetingUrl}">${event.meetingUrl}</a></p>` : ''}
          ${event.attendees && event.attendees.length > 0 ? 
            `<p><strong>Attendees:</strong> ${event.attendees.join(', ')}</p>` : ''}
        </div>
        
        ${agenda ? `
        <h3>Agenda:</h3>
        <div style="background-color: #f8fafc; padding: 15px; margin: 20px 0;">
          ${agenda.replace(/\\n/g, '<br>')}
        </div>
        ` : ''}
        
        <p>This reminder was automatically generated by Binate AI.</p>
      </div>
    `;
    
    // Get email address
    const userEmail = user.email;
    if (!userEmail) {
      console.error(`Cannot send meeting reminder: User ${userId} has no email address`);
      return false;
    }
    
    // Send the email
    const { sendPlainEmail } = await import('./email-sender');
    const sent = await sendPlainEmail(
      user,
      userEmail,
      `Meeting Reminder: ${event.title}`,
      meetingReminder,
      true // isHtml
    );
    
    // Send Slack notification
    let slackSent = false;
    try {
      // Check user preferences for Slack notifications
      const preferences = user.preferences ? 
        (typeof user.preferences === 'string' ? 
          JSON.parse(user.preferences) : user.preferences) 
        : {};
      
      // Only send Slack if notifications are enabled
      if (preferences.slackNotificationsEnabled !== false) {
        console.log(`Sending Slack meeting reminder for event ${eventId}`);
        
        const slackResult = await sendMeetingReminderNotification(
          userId,
          event.title,
          new Date(event.startTime),
          eventId,
          event.location || undefined,
          event.meetingUrl || undefined
        );
        
        slackSent = slackResult.success;
        
        if (slackSent) {
          console.log(`Slack meeting reminder sent for event ${eventId}`);
        } else {
          console.error(`Failed to send Slack meeting reminder for event ${eventId}: ${slackResult.errorMessage || 'Unknown error'}`);
        }
      }
    } catch (slackError) {
      console.error(`Error sending Slack meeting reminder for event ${eventId}:`, slackError);
    }
    
    if (sent || slackSent) {
      console.log(`Meeting reminder sent to ${userEmail} for event ${eventId} - Email: ${sent ? 'Yes' : 'No'}, Slack: ${slackSent ? 'Yes' : 'No'}`);
      
      // Update the event to mark reminder as sent
      await storage.updateEvent(userId, eventId, {
        reminderSent: true
      });
      
      return true;
    } else {
      console.error(`Failed to send meeting reminder for event ${eventId} (email and Slack both failed)`);
      return false;
    }
  } catch (error) {
    console.error(`Error sending meeting reminder for event ${eventId}:`, error);
    return false;
  }
}

/**
 * Generate meeting summary
 */
export async function generateMeetingSummary(userId: number, eventId: number) {
  try {
    const event = await storage.getEvent(eventId);
    
    if (!event || event.userId !== userId) {
      console.error(`Event ${eventId} not found or does not belong to user ${userId}`);
      return false;
    }
    
    // Check if summary already exists
    if (event.summary) {
      console.log(`Meeting summary already exists for event ${eventId}`);
      return true;
    }
    
    const user = await storage.getUser(userId);
    if (!user) {
      console.error(`User ${userId} not found`);
      return false;
    }
    
    // Generate meeting summary
    let meetingNotes = event.notes || '';
    if (!meetingNotes) {
      meetingNotes = `Meeting: ${event.title}\nAttendees: ${event.attendees ? event.attendees.join(', ') : 'Unknown'}\nAgenda: ${event.description || 'None provided'}`;
    }
    
    const summary = await generateMeetingSummaryFromNotes(meetingNotes);
    
    if (summary) {
      // Update the event with the summary
      await storage.updateEvent(userId, eventId, {
        summary
      });
      
      // Create tasks from summary if there are action items
      if (summary.includes('Action Item') || summary.includes('TODO') || summary.includes('Task')) {
        const actionItems = summary
          .split('\n')
          .filter(line => 
            line.includes('Action Item:') || 
            line.includes('TODO:') || 
            line.includes('Task:')
          );
        
        for (const item of actionItems) {
          // Extract the action item text
          const actionText = item.replace(/Action Item:|TODO:|Task:/, '').trim();
          
          // Create a task for each action item
          await storage.createTask({
            userId,
            title: actionText.substring(0, 100), // Ensure it's not too long
            description: `Generated from meeting: ${event.title}`,
            priority: 'medium',
            dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // Due in 7 days
            assignedTo: 'me',
            estimatedTime: 30,
            aiGenerated: true,
            completed: false,
            source: 'meeting',
            sourceId: event.id
          });
        }
      }
      
      // Format the email
      const summaryEmail = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333;">
          <h1 style="color: #2563EB;">Meeting Summary</h1>
          <p>Hello ${user.fullName || user.username},</p>
          <p>Here's a summary of your recent meeting:</p>
          
          <div style="background-color: #f8fafc; border-left: 4px solid #2563EB; padding: 15px; margin: 20px 0;">
            <h2 style="margin-top: 0; color: #2563EB;">${event.title}</h2>
            <p><strong>Date:</strong> ${new Date(event.startTime).toLocaleDateString()}</p>
            <p><strong>Time:</strong> ${new Date(event.startTime).toLocaleTimeString()} - ${new Date(event.endTime).toLocaleTimeString()}</p>
            ${event.attendees && event.attendees.length > 0 ? 
              `<p><strong>Attendees:</strong> ${event.attendees.join(', ')}</p>` : ''}
          </div>
          
          <h3>Summary:</h3>
          <div style="background-color: #f8fafc; padding: 15px; margin: 20px 0;">
            ${summary.replace(/\n/g, '<br>')}
          </div>
          
          <p>This summary was automatically generated by Binate AI based on the meeting details and notes.</p>
        </div>
      `;
      
      // Get email address
      const userEmail = user.email;
      if (!userEmail) {
        console.error(`Cannot send meeting summary: User ${userId} has no email address`);
        return false;
      }
      
      // Send the email
      const { sendPlainEmail } = await import('./email-sender');
      const sent = await sendPlainEmail(
        user,
        userEmail,
        `Meeting Summary: ${event.title}`,
        summaryEmail,
        true // isHtml
      );
      
      if (sent) {
        console.log(`Meeting summary sent to ${userEmail} for event ${eventId}`);
        return true;
      } else {
        console.error(`Failed to send meeting summary to ${userEmail} for event ${eventId}`);
        return false;
      }
    } else {
      console.error(`Failed to generate meeting summary for event ${eventId}`);
      return false;
    }
  } catch (error) {
    console.error(`Error generating meeting summary for event ${eventId}:`, error);
    return false;
  }
}

/**
 * Process emails to detect meeting requests
 */
export async function detectMeetingRequests(userId: number) {
  try {
    console.log(`Processing emails for user ${userId} to detect meeting requests`);
    
    // Get unprocessed emails
    const { getUnprocessedEmailsForMeetingDetection, markEmailProcessedForMeetingDetection } = await import('./gmail');
    const emails = await getUnprocessedEmailsForMeetingDetection(userId);
    
    if (!emails.length) {
      console.log(`No unprocessed emails found for meeting detection for user ${userId}`);
      return 0;
    }
    
    let meetingsCreated = 0;
    
    // Process each email
    for (const email of emails) {
      // Skip emails that don't appear to be meeting related
      const meetingKeywords = ['meeting', 'appointment', 'call', 'zoom', 'teams', 'hangout', 'schedule', 'calendar'];
      const isMeetingRelated = meetingKeywords.some(keyword => 
        email.subject?.toLowerCase().includes(keyword) || 
        email.body?.toLowerCase().includes(keyword)
      );
      
      if (!isMeetingRelated) {
        await markEmailProcessedForMeetingDetection(userId, email.id);
        continue;
      }
      
      // TODO: Implement AI-based meeting extraction logic here
      // For now, we'll just mark it as processed
      await markEmailProcessedForMeetingDetection(userId, email.id);
    }
    
    console.log(`Created ${meetingsCreated} meetings from emails for user ${userId}`);
    return meetingsCreated;
  } catch (error) {
    console.error(`Error detecting meeting requests from emails for user ${userId}:`, error);
    return 0;
  }
}

/**
 * Run autonomous calendar management
 */
export async function runAutoCalendarManagement() {
  try {
    const users = await storage.getAllUsers();
    
    for (const user of users) {
      // Get upcoming meetings in the next hour
      const events = await storage.getEventsByUserId(user.id);
      const now = new Date();
      const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000);
      
      const upcomingMeetings = events.filter(event => {
        const startTime = new Date(event.startTime);
        return startTime > now && startTime < oneHourFromNow && !event.reminderSent;
      });
      
      // Send reminders for upcoming meetings
      for (const meeting of upcomingMeetings) {
        await sendMeetingReminder(user.id, meeting.id);
      }
      
      // Look for meetings that just ended (in the last hour)
      const justEndedMeetings = events.filter(event => {
        const endTime = new Date(event.endTime);
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
        return endTime > oneHourAgo && endTime <= now && !event.summary;
      });
      
      // Generate summaries for meetings that just ended
      for (const meeting of justEndedMeetings) {
        await generateMeetingSummary(user.id, meeting.id);
      }
    }
    
    return true;
  } catch (error) {
    console.error('Error in autonomous calendar management:', error);
    return false;
  }
}